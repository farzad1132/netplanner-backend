%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Table of Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{NetPlanner\sphinxhyphen{}BackEnd}
\date{Oct 20, 2020}
\release{}
\author{Farzad Mohammadi}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


This documentation purpose is to explain NetPlanner BackEnd architecture and modules
and help future developers to contribute on this code more easily.

NetPlanner different parts are:
\begin{itemize}
\item {} \begin{description}
\item[{Web Server}] \leavevmode
This is front gate of backend and we are using \sphinxstylestrong{Nginx} here

\end{description}

\item {} \begin{description}
\item[{WSGI Server}] \leavevmode
This one is a interface that connects \sphinxstyleemphasis{web server} to \sphinxstyleemphasis{Service}
and here we are using \sphinxstylestrong{Gunicorn}.

\end{description}

\item {} \begin{description}
\item[{Service}] \leavevmode
This is where our actual logic ( algorithms, API, .. ) implemented
and here we are using \sphinxstylestrong{Flask}.

\end{description}

\item {} \begin{description}
\item[{Database}] \leavevmode
This is where we are storing algorithms results, users information and etc.
here we are using \sphinxstylestrong{Postgresql}.

\end{description}

\end{itemize}

We are going to discus all mentioned parts of backend in separate section


\chapter{In \sphinxstylestrong{Service} part we have below topics:}
\label{\detokenize{index:in-service-part-we-have-below-topics}}\begin{itemize}
\item {} 
Restful API and it’s specification

\item {} 
Routing of API

\item {} 
User Management

\item {} 
Security in API

\end{itemize}


\chapter{In \sphinxstylestrong{Database} part we have below topics:}
\label{\detokenize{index:in-database-part-we-have-below-topics}}\begin{itemize}
\item {} 
ORM system

\item {} 
Models

\end{itemize}


\section{Modules in NetPlanner BackEnd}
\label{\detokenize{modules:modules-in-netplanner-backend}}\label{\detokenize{modules::doc}}

\section{Main Objects Data Structure}
\label{\detokenize{ObjectDataStructures:main-objects-data-structure}}\label{\detokenize{ObjectDataStructures::doc}}

\section{Restful API with OpenAPI 3 and Routing}
\label{\detokenize{RestAPI:restful-api-with-openapi-3-and-routing}}\label{\detokenize{RestAPI::doc}}
In this section we are going deep to our Restful API.

specification link: \sphinxhref{http://spec.openapis.org/oas/v3.0.3}{OpenAPI 3}

We strongly suggest that after reading this documentation (which its purpose isn’t covering all of specification aspects) visit above web page
and learn more about OpenAPI 3

In order to simplify above specification, we can say our API is consist of several \sphinxstylestrong{paths}
and each path has several \sphinxstylestrong{verbs}.
\begin{description}
\item[{An example of path:}] \leavevmode
\sphinxcode{\sphinxupquote{/PhysicalTopology/read\_all}}

\end{description}

by verbs, we mean \sphinxstylestrong{HTTP method}.

After specifying path we have to define verbs of the path.
An example of \sphinxstylestrong{get} method for above path:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/PhysicalTopology/read\PYGZus{}all/\PYGZob{}user_id\PYGZcb{}:
  summary: Reading all PT\PYGZsq{}s
  get:
    tags:
      \PYGZhy{} Physical Topology
    summary: Reading all PT\PYGZsq{}s stored in Database
    security:
      \PYGZhy{} jwt: []
    operationId: PhysicalTopology.read\PYGZus{}all\PYGZus{}PT
    parameters:
      \PYGZhy{} \PYGZdl{}ref: \PYGZsq{}\PYGZsh{}/components/parameters/user_id\PYGZsq{}
    responses:
      200:
        description: Returning back all PT\PYGZsq{}s
        content:
          application/json:
            schema:
              type: array
              items:
                type: object
                properties:
                  name:
                    type: string
                  id:
                    type: integer
                    format: int64
                  create\PYGZus{}date:
                    type: string
                    format: date\PYGZhy{}time
                required:
                  \PYGZhy{} name
                  \PYGZhy{} id
                  \PYGZhy{} create\PYGZus{}date
      default:
        description: error handling
        content:
          application/json:
            schema:
              type: object
              properties:
                error\PYGZus{}msg:
                  type: string
              required:
                \PYGZhy{} error\PYGZus{}msg
\end{sphinxVerbatim}


\subsection{Usage of different components in our example code}
\label{\detokenize{RestAPI:usage-of-different-components-in-our-example-code}}\begin{itemize}
\item {} \begin{description}
\item[{\sphinxstylestrong{tags}}] \leavevmode
Tags used for grouping different paths that are related in some manner

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{security}}] \leavevmode
This one will be discussed in its own section ( see Security section )

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{operationId}}] \leavevmode
This one tells that which function in which module is responsible of handling this \sphinxstylestrong{(path, verb) pair}.
from above code we can tell that function with name \sphinxstyleemphasis{read\_all\_PT} and module \sphinxstyleemphasis{PhysicalTopology} is responsible
for this (path, verb).
\begin{description}
\item[{example of (path, verb) pair:}] \leavevmode
\sphinxtitleref{(/PhysicalTopology/read\_all/\{user_id\}, GET)}

\end{description}

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{parameters}}] \leavevmode
As its name speaks, this component defines this (path, verb) parameters.
As you can see in this code we have used \sphinxstyleemphasis{Reference} to prevent copying same exact code in multiple places.

References are defined at the top of specification file.
In this case definition is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{user_id}\PYG{p}{:}
  \PYG{n}{name}\PYG{p}{:} \PYG{n}{user_id}
  \PYG{o+ow}{in}\PYG{p}{:} \PYG{n}{path}
  \PYG{n}{required}\PYG{p}{:} \PYG{n}{true}
  \PYG{n}{schema}\PYG{p}{:}
    \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{integer}
\end{sphinxVerbatim}

As you can guess \sphinxstyleemphasis{name} is name of this parameter and we will use this in our handler function.
after that we have \sphinxstylestrong{in} keyword which specifies where is the place of this parameter
in HTTP request, \sphinxstyleemphasis{in} can be \sphinxstylestrong{query}, \sphinxstylestrong{path} or \sphinxstylestrong{header}.
After that we have \sphinxstyleemphasis{schema} section which defines parameter structure, in this example \sphinxstyleemphasis{Id} is simple integer type and
there is no need for advanced schema.

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{responses}}] \leavevmode
In this section we define different possible respond status codes ( HTTP status codes )
and for each one them we have to describe respond body structure( schema ).
In our example code we can see that for status code 200 this (path, verb) will return
an array of \sphinxstyleemphasis{JSON} object and each JSON object has three mandatory properties with the name of name, ida and create\_date.

Also there is an \sphinxstylestrong{default} responses. its usage in our application \sphinxhyphen{} \sphinxstyleemphasis{NOT IN GENERAL} \sphinxhyphen{}
is that we can return any status code other than 200 ( in this (path, verb) ) with an \sphinxstylestrong{error\_msg}.

\end{description}

\end{itemize}


\subsection{Brief look at handling function}
\label{\detokenize{RestAPI:brief-look-at-handling-function}}
This handling function corresponds to above api specification:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}all\PYGZus{}PT}\PYG{p}{(}\PYG{n}{user_id}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{PTs} \PYG{o}{=} \PYG{n}{PhysicalTopologyModel}\PYG{o}{.}\PYG{n}{query}\PYG{o}{.}\PYG{n}{filter\PYGZus{}by}\PYG{p}{(}\PYG{n}{user\PYGZus{}id}\PYG{o}{=} \PYG{n}{user_id}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{PTs}\PYG{p}{:}
      \PYG{k}{return} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{error\PYGZus{}msg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no Physical Topology found}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+m+mi}{404}
  \PYG{k}{else}\PYG{p}{:}
      \PYG{n}{schema} \PYG{o}{=} \PYG{n}{PhysicalTopologySchema}\PYG{p}{(}\PYG{n}{only}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{id}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{create\PYGZus{}date}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{many}\PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
      \PYG{k}{return} \PYG{n}{schema}\PYG{o}{.}\PYG{n}{dump}\PYG{p}{(}\PYG{n}{PTs}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{200}
\end{sphinxVerbatim}

First thing is that we can simply receive our parameter in function.
Then we can see application of default responses here as we returned an \sphinxstyleemphasis{error\_msg} with 404 status code
and at the last line you can see that we are returning a JSON object with status code of 200 ( its not clear how \sphinxtitleref{schema.dump(PTs)}
is a JSON object but leave it for now we will explain this later in \sphinxstylestrong{Models} section).


\subsection{request body in POST and PUT method}
\label{\detokenize{RestAPI:request-body-in-post-and-put-method}}
we started with GET method because its the easiest method to explain also its doesn’t require
request body.

Request Body is much like a responses body but its sent from user of the API to server

An example of request body definition:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
requestBody:
  description: providing information for creating new Physical Topology
  content:
    application/json:
    schema:
      \PYGZdl{}ref: \PYGZsq{}\PYGZsh{}/components/schemas/PhysicalTopology\PYGZsq{}
\end{sphinxVerbatim}

First of all this example proves our claim that request body is so much like response body,
Second we have used another Reference here for \sphinxstylestrong{PhysicalTopology} object.

PhysicalTopology and \sphinxstylestrong{TrafficMatrix} objects will be discussed in their own section

An example of extracting request body in handler function is as follow:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{create\PYGZus{}PhysicalTopology}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{user_id}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{PT} \PYG{o}{=} \PYG{n}{json}\PYG{o}{.}\PYG{n}{loads}\PYG{p}{(}\PYG{n}{request}\PYG{o}{.}\PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{PT\PYGZus{}object} \PYG{o}{=} \PYG{n}{PhysicalTopologyModel}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=} \PYG{n}{name}\PYG{p}{,} \PYG{n}{data}\PYG{o}{=} \PYG{n}{PT}\PYG{p}{)}
  \PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{PT\PYGZus{}object}\PYG{p}{)}
  \PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}

  \PYG{k}{return} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Id}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{PT\PYGZus{}object}\PYG{o}{.}\PYG{n}{id}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+m+mi}{201}
\end{sphinxVerbatim}

with \sphinxtitleref{json.loads(request.get\_data())} we can extract request body. ( you have to import \sphinxstylestrong{json} library ).


\subsection{Connection between Flask and OpenAPI}
\label{\detokenize{RestAPI:connection-between-flask-and-openapi}}
This is though if don’t use \sphinxstylestrong{connexion} library.
In connexion this can be done with this line of code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{connex\PYGZus{}app} \PYG{o}{=} \PYG{n}{connexion}\PYG{o}{.}\PYG{n}{App}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{,}
                          \PYG{n}{specification\PYGZus{}dir}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{basedir}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{openapi}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

In above code we simple gave \sphinxstylestrong{openapi.yaml} file path to app initializer.

We will explore more about this in \sphinxstylestrong{Modules} section.


\section{Routing}
\label{\detokenize{Routing:routing}}\label{\detokenize{Routing::doc}}
In this section we are going to explain Routing in NetPlanner Backend


\section{User Management}
\label{\detokenize{UserManagement:user-management}}\label{\detokenize{UserManagement::doc}}
In this section we are going to explain user management in NetPlanner BackEnd


\section{Security in Backend}
\label{\detokenize{Security:security-in-backend}}\label{\detokenize{Security::doc}}
In this section we are going to discus Security in different modules of NetPlanner


\section{Object Relational mapper}
\label{\detokenize{ORM:object-relational-mapper}}\label{\detokenize{ORM::doc}}
Here we are going to explore NetPlanner ORM


\section{Models and Tables in Database}
\label{\detokenize{Models:models-and-tables-in-database}}\label{\detokenize{Models::doc}}
Here we are going to dive into our Database and its structure


\section{Contact to Developers}
\label{\detokenize{Contact:contact-to-developers}}\label{\detokenize{Contact::doc}}\begin{itemize}
\item {} 
\sphinxstylestrong{Farzad Mohammadi}
\begin{quote}

\sphinxstylestrong{email}: \sphinxhref{mailto:farzad.mohammadi87@gmail.com}{farzad.mohammadi87@gmail.com}

\sphinxstylestrong{linkedin}: \sphinxurl{https://www.linkedin.com/in/farzad-mohammadi-119067159/}
\end{quote}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}